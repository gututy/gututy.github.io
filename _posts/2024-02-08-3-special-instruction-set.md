---
title: 特权指令系统
tags: 计算机体系结构 学习笔记
permalink: /notes/ca/special-instruction-set
aside:
    toc: ture
sidebar:
    nav: notes
---
> 第三章：特权指令系统
<!--more-->

# 特权指令系统简介
> 操作系统专用的指令系统结构

- 用户程序可以“看到”:(ABI, Application Binary InterFace, 应用程序二进制接口)
  - 用户态指令系统结构
  - 操作系统提供的系统调用
- 操作系统可以“看到”：
  - 用户态指令系统结构
  - 特权态指令系统结构
  - **编译器编不出特权态指令**

## 特权指令系统结构的作用
- 运行模式定义及切换
  - MIPS的user、supervisor、kernel模式，X86的Ring0-Ring3模式，LoongArch的PLV0-PLV3模式
  - 现代计算机的操作系统都实现了保护模式，至少需要用户态和核心态两种运行模式
  - 计算机刚启动时处于核心态，用户程序通过异常中断进入核心态
  - 操作系统在核心态通过设置控制寄存器或执行ERTN指令等进入用户态
- 虚拟存储管理
  - TLB对用户程序不可见，对操作系统可见
  - 与存储管理相关的控制寄存器，如页表起始地址
- 异常与中断处理
  - 用户程序需要操作系统服务时发出系统调用
  - 用户程序执行过程中出现的异常(如非法指令)
  - 外部中断(如敲击键盘)
- 控制状态寄存器(CSR)

## 控制状态寄存器
 - 用户态可见的寄存器
   - 通用寄存器
   - 浮点寄存器
   - 部分状态寄存器，如X86的EFLAG、LoongArch的FCSR
 - 核心态可以访问控制状态寄存器
   - 控制系统状态
   - 存储管理
   - 异常和中断处理
   - 调试和性能分析
   等等

![CSR1](/assets/ca/第三章图/CSR1.png)
![CSR2](/assets/ca/第三章图/CSR2.png)

# 异常和中断
## 异常
### 什么是异常
  - 使处理器从软件的***正常执行流中*** 脱离的事件，也称例外

### 异常分类(依据来源)
  - **外部事件**
    - 来自CPU流水线外部的事件，也称中断
      - 输入输出设备
      - 特点：独立于CPU指令流，纯异步
    - 使用中断模式后CPU计算可以与I/O处理并行
      - 为了得知I/O状态，需要CPU主动地查询
      - 绝大多数外设都采用中断模式(其他的采用定时查询)
  - **指令执行中的错误**
    - 不存在(未定义)的指令
    - 浮点除以0
    - 地址不对齐
    - 用户态下的无权限访问
      - 执行了只能在核心态下执行的指令
      - 访问了只能在核心态访问的地址空间
  - **数据完整性问题**
    - 存储器发生软错误，导致ECC或奇偶校验错误
       - > 软错误：可恢复的电位翻转
         >
         > 通常来源于高能粒子冲击
         >
         > 减少软错误的方法：使用抗辐照的工艺；使用纠错机制(如ECC校验、三模冗余校验)
  - **地址转换异常**
    - 从虚地址到物理地址转换时没有有效的TLB项(TLB详见后文)
    - TLB异常
      - TLB重填异常
      - 页表项无效异常(取指、Load、Store)
      - 页修改异常
      - 页不可读异常
      - 页不可执行异常
  - **系统调用和陷入**
    - 专用指令产生，软件故意产生的异常
      - 系统调用(syscall)：操作系统为用户态程序访问核心态资源准备的接口
      - 陷入(break)：软件预设的端点，如整数除零检查
  - **需要软件修正的运算**
    - 通常来源于浮点运算指令
    - 比如操作数特别小(非规格化非0的数)

![LoongArch异常](/assets/ca/第三章图/LoongArch异常.png)

### 异常处理流程
- **异常处理准备**
  - 需要记录被异常打断的指令的地址(记为EPTR)：LoongArch中存在CSR.ERA
  > 精确异常：异常发生时被异常打断的指令前的指令都已经执行完，该指令后的指令都未执行
  - 调整CPU的权限等级并关闭中断响应：LoongArch中将CSR.PLV置为0进入最高特权等级，并将CSR.CRMD的IE域置0来屏蔽所有中断输入
  - 硬件保存异常发生现场的部分信息：将CSR.CRMD中的PLV和IE的旧值分别记录到CSR.PRMD的PPLV和PIE中
  - 记录异常的有关信息：记录异常编号
- **确定异常来源**
  - X86：由硬件确定异常编号，根据编号查询中断描述符表(IDT)得到不同异常处理的入口地址
  - LoongArch：将不同的异常进行编号，异常处理程序入口采用“入口页号与页内偏移进行按位逻辑或”的计算方式，入口页号通过CSR.EENTRY配置，每个普通异常处理程序入口的页内偏移是其异常编号乘以一个可配置间隔（通过CSR.ECFG的VS域配置）
- **保存执行状态**
  - 将被打断程序的状态保存到栈中供恢复，包括所有的通用寄存器和程序状态字寄存器等其它需要保存的扩展部件寄存器
  - 根据中断优先级要求关闭或保留部分中断使能
- **执行异常处理**
  - 根据确定好的异常处理入口地址跳转到对应的处理程序并清除中断源状态
  - 处理程序很长时只处理较为紧急的部分防止影响对其他中断的响应
- **恢复执行状态**
  - 从栈中恢复相关寄存器的值
- **返回正常执行流**
  - 从异常返回正常的执行流：核心态变为用户套的模式切换和地址变化同时完成，用专用的异常返回指令(LoongArch的ERTN，X86的IRET)来原子的完成恢复权限等级、恢复中断使能状态、跳转至异常返回目标

### 异常嵌套
- 异常处理中产生了新的异常如何处理？
- 将异常分为多个不同的优先级，更高优先级的异常可以抢占处理，同优先级或低优先级的只能等待

## 中断
### 中断输入
> LoongArch定义了13个中断：1个核间中断(IPI)、1个定时器中断(TI)、1个性能检测计数溢出中断(PMI)、8个外部硬中断(HWI0\~HWI7)和2个软中断(SWI0\~SWI1)，均为可屏蔽中断(走INTR线)
>
> //不可屏蔽中断走NMI线

### 中断优先级
- 多个中断同时发生时需要有优先级区别
- 正常执行状态下CPU在最低优先级，所有中断都可以触发
- 处于最高中断优先级时，任何中断都被禁止
- 更高优先级的中断发生时可以抢占低优先级的中断处理流程
- 向量中断模式时优先度从大到小分别是IPI、TI、……、SWI0
- 硬件不区分中断优先级时由软件维护一个中断优先级(IPL)对每个中断源赋予特定的优先级

### 向量化中断
- 嵌入式CPU中对中断处理实时性由较高的入口
  - 通用CPU可以只有一个中断入口，由软件在中断处理时识别中断类型再分别处理
  - 嵌入式CPU中每个中断有独立的入口，不同中断到不同入口直接处理
- LoongArch向量化中断
  - 13个中断各自具有独立的中断处理程序入口地址
  - 具体计算时将SWI0\~IPI这些中断依次“视为”异常编号64\~76的异常，用异常处理程序入口地址的统一计算方式进行计算
- X86的原生向量化中断
  - 在地址空间的特定位置处保存中断向量表(IVT，实模式下默认为0地址)或中断描述符表(IDT，保护模式)，中断向量表中存放中断入口地址的段地址和偏移量，中断描述符表包含特权等级和描述符类别等信息，硬件完成中断号的识别和入口地址查表
  - 最多可支持256个异常和中断：0\~19号为系统预设的异常和NMI，20\~31是Intel保留的编号，32号开始可用于外部中断

### 中断传递
如何把来自各个设备的各种中断信号传递到CPU？
#### 中断线传递
- 专用的信号线传输中断
  - 边沿中断：由信号变化的边沿表示，需要在中断控制器记录
  - 电平中断：由中断线的点评高低表示，信号传递途中无存储
  - 一种LoongArch系统中断实现
  - ![LoongArch中断线](/assets/ca/第三章图/LoongArch中断线实现.png)
- 缺陷
  - 中断来源的判断
    - CPU引脚资源有限，导致多个外设挂在同一条中断线上
    - 怎么知道谁发了中断？逐个设备查询，Linux中一个IRQ(Interrupt Request)号上可以挂载多个ISR(Interrupt Service Routines，中断服务程序)
  - 如果有多个CPU，中断哪一个？
    - 由硬连线决定，可以在中断控制器重定向
    - 如何做到负载均衡？如何让存在前后关联的中断在同一个CPU处理？
  - 中断线与外设信息的一致性
    - 中断发到CPU后要确保CPU读到正确的外设或内存信息
    - 外设把有关信息写到内存后再发中断，在CPU向外设查询时再清中断
#### 通过中断消息传递
- Message Signaled Interrupt(MSI)
  - 无需专门的中断线，扩展性强，一个设备可申请多个中断
  - 外设通过总线(如PCIE总线)通过包的方式向CPU发中断消息，写到CPU内部的中断控制器上触发中断，OS实现给每个外设分配MSI向量(发中断的写地址)
- 降低中断处理延迟
  - CPU被中断后，读中断控制器的状态确定中断号，逐个执行挂在该中断号下的ISR，ISR去访问设备寄存器确定是否发生中断，如果有再进一步处理并清中断
  - 不用读远在桥片的中断控制器，不用读可能更远的外设寄存器，避免中断号共享
- 实现负载均衡
  - 实现多CPU负载均衡
    - 在设备端进行中断分配
    - 多队列，对应不同的CPU
    - 接收到的包，分析包头确定网络流，相同流的包放到同一个队列，优化局部性

# 存储管理
 一个访存例子

- 一个程序片段
array = (int*)malloc(0x1000);
for(i = 0; i < 1024; i++) array\[i]= 0;
- 软件功能
  - 分配一个1024项的一维整数数组array，并初始化为0
- 硬件过程？
  - 数组地址分配在什么地址？
  - 数组存在什么地方(内存/硬盘)？
  - 什么时候分配？什么时候存？
  - 虚地址和物理地址如何转换？

 利用存储空间分布进行攻击的例子
- 利用缓冲区溢出进行攻击的例子

![攻击](/assets/ca/第三章图/缓冲区溢出进行攻击.png)

## 虚拟存储原理
- 虚拟存储是计算机系统发展过程中有里程碑作用的事件
  - 多进程环境下统一的编程空间
  - 多进程环境下的共享与保护
  - 支持大于实际物理内存的编程空间
- 虚实地址分开，建立一种从虚地址空间映射到物理内存的机制
  - 把两个层次的存储转换为一个层次的存储
  - 物理内存实际上是磁盘的一个Cache
- 作用和意义
  - 隐藏和保护
  - 为程序分配连续的内存空间
  - 扩展地址空间
  - 节约物理内存

## 虚实地址转换与页表
- 在页的范围内虚实地址相等
- TLB是页表的Cache

![TLB](/assets/ca/第三章图/TLB1.png)

- 多级页表
  
![多级页表](/assets/ca/第三章图/多级页表.png)

## TLB $\star$
- TLB实际上是操作系统中页表的Cache
  - TLB负责完成用户空间到物理空间的转化
  - 一般与Cache访问同时进行
  - TLB内容：虚地址(Cache 的Tag)、物理地址(Cache 的Data)、标志位(Cache 的状态)
- TLB失效处理
  - TLB失效时需要把相应页表内容从内存取到TLB
  - TLB失效时硬件(如X86的hardware page walker)和软件(如LoongArch 的TLB重填异常)来填充TLB

---
Cache和虚拟存储

![Cache和虚拟存储](/assets/ca/第三章图/Cache和虚拟存储.png)

---

分清两种映射关系
- TLB是页表的Cache
  - 负责地址转换，一页管4KB以上数据
  - 页表由操作系统管理，存在系统空间
- 内存是硬盘的Cache
  - 负责数据缓存，一字节就是一字节
  - 用户程序的数据在用户空间
- **对应两种TLB失效**
  - **在TLB中找不到对应项，需要查找页表**
  - **在TLB中找到对应项，但相应页不在内存(未分配或已调出内存)**

## LoongArch对虚拟存储的支持
### 地址空间
- LoongArch指令系统中虚拟空间是线性平整的
  - 对PLV0级来说，LA32架构下虚拟地址空间大小为$2^{32}$字节
  - 对PLV0级来说，LA64架构下虚拟地址空间大小为$2^{64}$字节，但存在一些非法的虚拟地址空洞，其与地址映射模式紧密相关
- LoongArch支持的物理内存地址空间范围表示为$0$\~$2^{PALEN}-1$
  - LA32架构下，PALEN理论上是一个不超过36的正整数
  - LA64架构下，PALEN理论上是一个不超过60的正整数

### 地址翻译模式
- 两种虚实地址翻译模式：直接地址翻译模式和映射地址翻译模式
  - 直接地址翻译模式：物理地址直接等于虚拟地址(高位不足补0，超出截断)
  - 映射地址翻译模式：分为直接映射地址翻译模式(简称“直接映射模式”)和页表映射地址翻译模式(简称“页表映射模式”)两种
    - 直接映射模式通过直接映射配置窗口机制完成虚实地址翻译
    - 页表映射模式通过页表映射完成虚实地址转换

### TLB结构
- LoongArch的TLB分为两个部分
  - 单一页大小TLB(Singular-Page-Size TLB，简称STLB)，多路组相联
  - 多重页大小TLB(Multiple-Page-Size TLB，简称MTLB)，全相联
- 在虚实地址转换过程中，STLB和MTLB同时查找


#### TLB表项结构

![TLB表项结构](/assets/ca/第三章图/TLB表项.png)

- E：该TLB表项是否存在
- ASID：标记该TLB表项属于哪个地址空间
- G：全局域，为1时表示属于所有的地址空间
- PS：表示该页表项中存放的页大小
- VPPN：虚双页号
- PPN：物理页号
- PLV：表示该页表项对应的权限等级
- RPLV：受限权限等级使能，为0时表示该页表项可以被任何权限等级不低于PLV的程序访问，为1时表示仅可以被权限等级等于PLV的程序访问
- MAT：控制落在该页表项所在地址空间上的访存操作的存储访问类型
- NX：不可执行位，为1时表示该页表项所在地址空间上不允许执行取指操作
- NR：不可读位，为1时表示该页表项所在地址空间上不允许执行load操作
- D：“脏”(Dirty)位，为1时表示该页表项所对应的地址范围内已有脏数据
- V：有效位，为1时表示该页表项有效且被访问过


#### TLB有关的CSR

![TLB.CSR](/assets/ca/第三章图/CSR.TLB.png)


#### TLB管理有关的指令
- TLBRD
  - 以TLBIDX中的Index域的值为索引把TLB内容读到TLBEHI、TLBELO0/1、TLBIDX等CSR中
- TLBWR
  - 以TLBIDX中的Index域的值为索引把TLBEHI、TLBELO0/1、TLBIDX等CSR中的内容写入TLB
- TLBSRCH
  - 检查ASID和TLBEHI中指定的虚页是否在TLB中
- TLBFILL
  - 把TLBEHI、TLBELO0/1、TLBIDX等CSR中的内容写入TLB的一个随机位置
- INVTLB
  - 从通用寄存器rj和rk得到用于比较的ASID和虚地址信息，依照指令op立即数指示的无效规则对TLB中的表项逐一进行判定，符合条件的TLB表项将会被无效掉

#### TLB相关异常
- TLB重填异常(TLBR)
  - 如果查找TLB没有找到一个虚地址匹配(VPPN+ASID/G)
- 页无效异常
  - 如果找到一个虚地址匹配项，但V=0
  - 分为三种：取指操作页无效异常(PIF)、load操作页无效异常(PIL)、store操作页无效异常(PIS)
- 页权限等级不合规异常(PPI)
  - 如果找到一个虚地址匹配且其V=1，但访问的权限等级不合规
  - 权限等级不合规体现为该命中页表项的RPLV=0且CSR.CRMD中的PLV值大于命中页表项中的PLV值；或该命中页表项的RPLV=1且CSR.CRMD中的PLV值不等于命中页表项中的PLV值
- 页修改异常(PME)
  - 如果找到一个虚地址匹配且其V=1，但D=0且是store操作
- 页不可读异常(PNR)
  - 如果找到一个虚地址匹配且其V=1，但NR=1且是load操作
- 页不可执行异常(PNX)
  - 如果找到一个虚地址匹配且其V=1，但NX=1且是取指操作

#### 发生异常时硬件处理过程
- TLB重填异常
  - 更新CSR.CRMD，其中PLV、IE域的旧值被记录到CSR.TLBRPRMD
  - 异常返回地址(触发异常的指令PC)填入CSR.TLBRERA的PC域中，**并将IsTLBR置1**
  - 引发该异常的访存虚地址填入CSR.TLBRBAV的VAddr域
  - 从该虚地址提取出虚双页号填入到CSR.TLBREHI的VPPN域
  - PC=TLB重填异常入口地址（由CSR.TLBRENTRY配置）
- 其他TLB异常
  - 更新CSR.CRMD，其中PLV、IE域的旧值被记录到CSR.PRMD
  - 异常返回地址(触发异常的指令PC)填入CSR.ERA的PC域中
  - 引发该异常的访存虚地址填入CSR.BADV的VAddr域
  - 从该虚地址提取出虚双页号填入到CSR.TLBREHI的VPPN域
  - PC=对应异常入口地址
- 异常返回
  - 异常处理在核心态下进行
    - 不允许在用户态下执行核心态指令
  - 异常返回方式
    - ERTN指令，同时置为用户态

### 存储管理
- 内存中的页表组织
  - 三级页表，每项8个字节
  - 一级页表每一项保存一个二级页表的起始地址，二级页表每一项保存一个三级页表的起始地址
  - 页表项内容
    - PPN：物理页号
    - Flags：RPLV、NX、NR、PPN、W、P、G、MAT、PLV、D、V
      - P：物理页是否存在
      - W：该页是否可写
    - exts：软件扩展位，用于维护一些硬件没有实现的功能
  - 页表通过直接映射方式访问
    - 页表访问不引起TLB相关异常
    - 页表存储空间在使用到的时候分配
  - 每个进程的页表基址存放在进程上下文中

#### LoongArch三级页表及其查找过程

![LoongArch三级页表](/assets/ca/第三章图/LoongArch三级页表查找.png)

#### 加速多级页表遍历
- 定义LDDIR和LDPTE指令以及CSR.PWCL和CSR.PWCH来加速遍历

|指令|描述|
|:--:|:---:|
|LDDIR rd, rj, level|将rj寄存器中的值作为当前页目录表的基地址，同时根据CSR.TLBRBADV中VAddr域存放的TLB缺失地址以及PWCL、PWCH寄存器中定义的页目录表level的索引的起始位置和位宽信息计算出当前目录页表的偏移量，两者相加作为访存地址，从内存中读取第待访问页目录表/页表的基址，写入到rd寄存器中。|
|LDPTE rj, seq|将rj寄存器中的值作为末级页表的基地址，同时根据CSR.TLBRBADV中VAddr域存放的TLB缺失地址以及PWCL、PWCH寄存器中定义的末级页表索引的起始位置和位宽信息计算出末级页表的偏移量，两者相加作为访存地址，从内存中读取偶数号(seq=0)或奇数号(seq=1)页表项的内容，将其写入到TLBRELO0或TLBRELO1寄存器中。|

- CSR.PWCL
  - PTEWidth域：每个页表项的宽度
  - PTbase和PTwidth：末级页表索引的起始位置和位宽
  - Dir1_base和Dir1_width域：页目录表1索引的起始位置和位宽
  - Dir2_base和Dir2_width域：页目录表2索引的起始位置和位宽
- CSR.PWCH
  - Dir3_base和Dir3_width域：页目录表3索引的起始位置和位宽
  - Dir4_base和Dir4_width域：页目录表4索引的起始位置和位宽

#### TLB重填代码

```nasm
csrwr     $t0, CSR_TLBRSAVE
csrrd     $t0, CSR_PGD
lddir     $t0, $t0, 3       # 访问页目录表PGD
lddir     $t0, $t0, 1       # 访问页目录表PMD
ldpte     $t0, 0            # 取回偶数号页表项
ldpte     $t0, 1            # 取回奇数号页表项
tlbfill
csrrd     $t0, CSR_TLBRSAVE
ertn
```

在Linux/LoongArch中当进行三级页表的遍历时，通常用Dir1_base和Dir1_width域来配置页目录表PMD索引的起始位置和位宽，用Dir3_base和Dir3_width域来配置页目录表PGD索引的起始位置和位宽，Dir2_base和Dir2_width域、Dir4_base和Dir4_width域空闲不用

#### 其他TLB异常处理
- 页修改异常
```
TLB modified exception:
  (1) load pte;
  (2) if(_PAGE_WRITE) set VALID|DIRTY, reload tlb, tlbwr;
      else DO_FAULT(1);
```
- 取指操作页无效异常/load操作页无效异常
```
TLB load exception:
  (1) load pte;
  (2) if(_PAGE_PRESENT && _PAGE_READ) set VALID, reload tlb, tlbwr;
      else DO_FAULT(0);
```
- store操作页无效异常
```
TLB store exception:
  (1) load pte;
  (2) if(_PAGE_PRESENT && _PAGE_WRITE) set VALID|DIRTY, reload tlb, tlbwr;
      else DO_FAULT(1);
```
> load pte函数遍历页表并取得页表项
>
> DO_FAULT函数在内存中分配物理页并把该页内容从对换区中取到内存
>
> _PAGE_PRESENT、_PAGE_READ和_PAGE_WRITE分别表示相应的物理页是否在内存中、是否可读、是否可写

### 一个例子
#### 一个简单的程序
```c++
array = (int*)malloc(0x1000);
for (i = 0; i <1024; i++) array[i] = 0;
```

- array = (int*)malloc(0x1000)
  - 用户程序malloc(0x1000)返回一个虚地址0x450000
  - 操作系统在该进程的vma_struct链表中记录地址范围0x450000\~0x451000为已分配地址，可读可写
> 但是操作系统只是分配了一个地址范围，没有真实分配内存的物理空间，也没有在页表里建立页表项，TLB里更没有——因为如果进程没有访问，就不用为其真分配物理空间
- for (i =0; i <1024; i++) array[i] = 0
  - 用户程序试图写0x450000，TLB没有这一表项，TLB查找失败，触发TLB重填异常
  - TLB重填异常处理程序从相应页表位置取入页表内容填入TLB，但该页表还没有初始化，没有有效的页表项信息
  - 异常返回到用户程序重新开始访问
  - TLB表项找到，但是没有物理地址，无效，触发store操作页无效异常
  - 操作系统查找vma_struct，判断该地址已分配且处于可写状态，因此分配物理页面，并将物理地址填入页表，更新TLB相应的表项
  - 异常返回，写操作再次重试，成功
  - 用户程序继续写0x450004，0x450008...，因为TLB项已经存在，将全速运行，除非中间发生进程切换导致TLB项被换出。如果发生被换出的情况，再次运行时将发生TLB重填异常，重新从页表取得有效内容，不会再触发store操作页无效异常(所以TLBR频率>>页无效异常)
- **为什么分成两次异常？为什么TLBR例外特殊处理？**
  - 保证TLBR的处理速度

#### 一个计算例子
- 程序段
```c++
array = (int*)malloc(0x10000);
for (i =0; i < 16384; i++) array[i] = 0;
```
- 页大小为4KB，初次执行发生了多少次异常？
  - 地址空间大小为64KB，16页
  - 发生8次TLBR(TLB一项两个连续虚页)和16次store操作页无效异常
- 页大小为16KB，初次执行发生了多少次异常？
  - 发生2次TLBR和4次store操作页无效异常
- 页大小为4KB，上述程序段执行完后发生进程切换，再切换回该进程执行程序段for循环
  - 如果进程切换时TLB项被全部替换，只发生8次TLBR
  - 如果进程切换时array被调出内存，发生8次TLBR和16次store操作页无效异常，store操作页无效异常处理时把array从硬盘调到内存
  - 如果页表也被调出内存？

### TLB优化
- 利用TLB保护机制防范攻击
  - 通过可执行位保护防止缓冲区溢出攻击

[缓冲区溢出攻击](#存储管理)
- TLB miss占用处理时间多
  - 优化方法
    - 增加TLB覆盖空间大小，降低TLB失效概率(增加页大小)
    - 降低TLB失效开销