---
title: 运算器设计
tags: 计算机体系结构 学习笔记
permalink: /notes/ca/ALU
aside:
    toc: ture
sidebar:
    nav: notes
---
> 第八章：运算器设计
<!--more-->

# 二进制与逻辑电路
## 计算机中数的表示
要表示的数有哪些
- 整数(正整数、0、负整数)
- 有理数和无理数(0.1、$\frac{2}{3}$、$\pi$)
- 字符串(通过ASCII码转换为数字，00表示字符串结束)

### 数制
- 根据进位方式的不同，划分为不同数制
- 对于任意R进制数$A=a_na_{n-1}...a_1a_0a_{-1}a_{-2}...a_{-m+1}a_{-m}$所表示的十进制数为
  $$
  Value(A) = a_n \times R^n + a_{n-1} \times R^{n-1} + ... + a_1 \times R^1 + a_0 \times R^0 + a_{-1} \times R^{-1} + a_{-2} \times R^{-2} + ... + a_{-m+1} \times R^{-m+1} + a_{-m} \times R^{-m}
  $$
- 为什么计算机用二进制
  - 格式简单，只有0/1两个数，正好对应逻辑命题的真和假
- 定浮点表示
  - 定点数
    - 小数点固定(最右边)
    - 用于表示整数
  - 浮点数
    - 小数点可以浮动
    - 用于表示实数


### 定点数的编码规则
#### 原码：直接表示二进制
- 将数去掉符号位表示成二进制，对齐长度之后补上符号位
- 优点：
  1. 与人们日常记录正负数的习惯相近，与真实数值之间的对应关系直观，利于与真实数值相互转换
  2. 原码实现乘除运算比较简便直接
- 缺点：
  1. 存在两个0，+0和-0
  2. 原码的加减运算规则复杂，需要判断是否是同号相减或者是异号相加，如果是需要根据绝对值大小判断结果的正负号

#### 补码
- 定义：$[X]_补 = 2^n + X (mod \space 2^n), \space\quad -2^{n-1} \leq X < 2^{n-1}$
- 简便算法
  - 正数补码是本身($[X]_补=X$)
  - 负数补码是本身的值按位取反后+1($[X]_补= \overline{X} +1 $)
  - 最高位还是符号位
- 优点
  - $[X+Y]_补 = [X]_{补} + [Y]_{补}$
  - $[X-Y]_补 = [X]_补 + \overline{[Y]_补} +1$
  - 比原码能多表示一个数($-2^{n-1}$)

#### 溢出
- 同号相加或异号相减可能溢出
- **溢出就是运算的算术结果超出了表示范围**

### 浮点数表示
> 定点数只能表示整数，除法不准确
> 定点数表示范围较小
> 如何表示浮点数中的小数点(IEEE754标准)

#### IEEE754标准
- 浮点数标识为符号位S、尾数F和阶码E
  - 科学计数法：没有前导零，小数点左侧只有一个整数
- 规定
  - 符号S为0表示正数
  - 尾数F用$\color{#FF0000}{原码}$表示，为101...
  - 阶码E用$\color{#FF0000}{移码}$表示，1+shift；偏移常量对于单精度和双精度的来说分别是127和1023
  - 数的位数
    - 单精度：1位S，8位E，23位F
    - 双精度：1位S，11位E，52位F
  
![IEEE754](/assets/ca/第八章图/IEEE754.png)

- 一些特殊值
  - 无穷大(阶码全1尾数全0)
  - 非数(阶码全1尾数非0)
  - 零(阶码全0尾数全0)
  - 非规格化非零(阶码全0尾数非0)

## MOS晶体管工作原理
- P型材料
  - 硅(Si)中掺杂3价元素(硼B)，有空穴
- N型材料
  - 硅(Si)中掺杂5价元素(磷P)，有自由电子
- PN结
  - P型材料和N型材料挨在一起，少量电子从N向P流动
  - P区带了负电，N区带了正电，形成稳定区
![MOS管原理](/assets/ca/第八章图/MOS管原理.png)
![MOS管原理2](/assets/ca/第八章图/MOS管原理2.png)

### NMOS管
- 两块掺杂度较高的N区，掺杂度较低的P区衬底
- 还包括源极、漏极、栅极和栅氧层

![NMOS1](/assets/ca/第八章图/NMOS1.png)
- 当栅极接地时，不导电
  - 两对PN结形成稳定区
  - 两片电子密集区不导通

![NMOS2](/assets/ca/第八章图/NMOS2.png)
- 当栅极接高电压时，形成沟道，导电
  - 栅氧层存在电势差，将P区少量自由电子吸引聚集
  - 形成电子沟道，使得两块N区导通，电势差导致电子流通

![NMOS3](/assets/ca/第八章图/NMOS3.png)

### PMOS管
- 两块掺杂度高的P区，掺杂较低的N区衬底

![PMOS1](/assets/ca/第八章图/PMOS1.png)
- 当栅极接地，空穴区联通

![PMOS2](/assets/ca/第八章图/PMOS2.png)

- 当栅极接电，空穴区断开

![PMOS3](/assets/ca/第八章图/PMOS3.png)

----------

- NMOS，栅接高电压，源和漏导通

![NMOS开关](/assets/ca/第八章图/NMOS等效开关.png)

- PMOS，栅接地，源和漏导通

![PMOS开关](/assets/ca/第八章图/PMOS等效开关.png)

### 使用MOS管设计CMOS逻辑电路
- 使用互补(Complementary)的PMOS和NMOS组成电路
  - 不论什么输入输出，都不会有从电源到地的直流漏电
- 有些定制电路为了速度直接使用NMOS或PMOS

![CMOS1](/assets/ca/第八章图/CMOS1.png)![CMOS2](/assets/ca/第八章图/CMOS2.png)![CMOS3](/assets/ca/第八章图/CMOS3.png)

## CMOS逻辑电路
### 数字逻辑电路
#### 布尔代数
- 布尔代数是在二元集合{0,1}上定义的运算
- 包含与( \& )、或( \| )、非( \~ )三种运算
- 基础运算定律：
  - A \| 0 = A, A & 1 = A, A \| 1 = 1, A & 0 = 0
  - A \| A = A, A & A = A, A \| \~A = 1, A & \~A = 0
  - A \| B = B \| A, A & B = B & A
  - A \| (B \| C) = (A \| B) \| C, A & (B & C) = (A & B) & C
  - A & (B \| C) = (A & B) \| (A & C), A \| (B & C) = (A \| B) & (A \| C)
  - \~(A & B) = \~A \| \~B, \~(A \| B) = \~A & \~B
  - A \| A & B = A, A \| ~A & B = A \| B

#### 真值表
- 数字逻辑电路基于布尔代数
- 真值表是一种布尔函数的描述方式
  - 对于每一种可能的输入组合，给出输出值。对于一个n输入的电路，有$2^n$项

![真值表1](/assets/ca/第八章图/真值表1.png)
- 常见的运算
  - 使用基础的3个运算，搭建常见的逻辑表达式

![真值表2](/assets/ca/第八章图/真值表2.png)
- 根据真值表，可以直接写出逻辑表达式
  - 先用与&表示每个输出为1的子句，再或\|起来
- 以下面的真值表为例(一位全加器)
  - 输入：A, B, Cin; 输出：S, Cout
  - S = \~A & \~B & Cin \| \~A & B & \~Cin \| A & \~B & \~Cin \| A & B & Cin
  - Cout = \~A & B & Cin \| A & \~B & Cin \| A & B & \~Cin \| A & B & Cin

![真值表3](/assets/ca/第八章图/真值表3.png)

- 卡诺图
  - 根据真值表进行化简，写出更简便的等价逻辑表达式
    - 将相邻的“1”或“X”合并为一项

![卡诺图1](/assets/ca/第八章图/卡诺图1.png)
> S = \~A & \~B & Cin \| \~A & B & \~Cin \| A & \~B & \~Cin \| A & B & Cin

![卡诺图2](/assets/ca/第八章图/卡诺图2.png)

#### 组合逻辑与时序逻辑
- 组合逻辑
  - 电路的输出只由当前时刻的输入决定
  - 之前介绍的各种数字逻辑电路
- 时序逻辑
  - 电路的输出和曾经的输入有关
  - 内部有存储单元
  - 时钟信号是时序逻辑电路的基础

#### 时序逻辑
- RS触发器
  - 其它寄存器电路的基础

![RS触发器1](/assets/ca/第八章图/RS触发器1.png)![RS触发器2](/assets/ca/第八章图/RS触发器2.png)

- D触发器
  - D锁存器
  - ![D锁存器](/assets/ca/第八章图/D锁存器.png)
  - D触发器
  - ![D触发器](/assets/ca/第八章图/D触发器.png)
- ![D触发器时间](/assets/ca/第八章图/D触发器时间.png)
  
- 使用组合逻辑和触发器，可以搭建复杂的时序逻辑

![时序逻辑与组合逻辑结合](/assets/ca/第八章图/时序+组合.png)

### 数字逻辑的CMOS表达
- 使用PMOS和NMOS实现组合逻辑电路：
  - 非(反相器)
  - 与非
  - 或非
- 通过卡诺图获得的电路只有“非”和“与非”

#### CMOS电路
- 使用互补(Complementary)的PMOS和NMOS组成电路
  - 不论什么输入输出，都不会有从电源到地的直流漏电

#### CMOS反相器(非运算)
- 当A接地，P管导通，N管关闭，输出为高
- 当A接电，P管关闭，N管导通，输出为低

![CMOS反相器](/assets/ca/第八章图/CMOS反相器.png)
#### 与非门
![CMOS与非门](/assets/ca/第八章图/CMOS与非门.png)
#### 或非门
![CMOS或非门](/assets/ca/第八章图/CMOS或非门.png)
#### 传输门和D触发器
- 传输门根据使能，决定是否对信号导通
- 一个P管和一个N管的源极连在一起，漏极连在一起
![传输门](/assets/ca/第八章图/CMOS传输门.png)
- D锁存器和D触发器
  - 框内为去除输出缓冲器的D锁存器

![D触发器](/assets/ca/第八章图/CMOS触发器.png)
### CMOS电路延迟
- CMOS电路的输出端对地有电容
  - P管和N管漏极的寄生电容
  - 下一级电路栅电容
  - 连线电容

![CMOS电容延迟](/assets/ca/第八章图/CMOS电容延迟.png)

- 电容的充放电需要时间，电压变化也不是瞬间完成的

![CMOS延迟](/assets/ca/第八章图/CMOS延迟.png)
# 阶段重点
- 数的表示
  - 二进制和十进制的转换
  - 原码、补码的原理和表示范围，补码和原码的转换(负数按位取反加1方法)
  - 浮点数的表示：IEEE754标准
- 晶体管级电路
  - N管和P管的基本原理
  - CMOS电路的基本原理，用CMOS实现基本门单元
  - D触发器的基本原理

# 简单运算器设计
## 定点补码加法器
### 一位全加器
- 一位全加器
  - 三个输入：A, B, Cin
  - 两个输出：S, Cout
[真值表见前](#真值表)

![一位全加器](/assets/ca/第八章图/一位全加器.png)
- 一共56个晶体管(三个反相器3$\times$2+与非门每条输入两个晶体管(18+7)$\times$2=56)
- 近似认为每个一位全加器有2或3级门延迟
- 一位全加器是两个数加法器的基础
  - A和B是加数/被加数
  - $C_{in}$是进位输入
  - S是当前输出
  - $C_{out}$是进位输出

### 行波进位加法器
- 将N个一位全加器串接起来
  - 进位传递
- 延迟随位数增长线性增长

![行波进位加法器](/assets/ca/第八章图/行波进位加法器.png)
#### 延迟计算
- 1位全加器延迟
  - 从$A$、$B$和$C_{in}$到$S$：3级门
  - 从$A$、$B$和$C_{in}$到$C_{out}$：2级门
- 32位全加器延迟
  - 从$A_0B_0$和$C_{in}$到$C_{31}$：$2\times31=62$级门
  - 从$C_{31}$到$S_{31}$：3级门
  - 从$C_{31}$到$C_{out}$：2级门
  - 最大延迟：65级门
- 64位全加器延迟：129级门
  - $S_{63}$：$63\times2+3=129$级门
  - $C_{out}$：$64\times2=128$级门

### 先行进位加法器
#### 进位逻辑
- 串行进位延迟太长
- 分析进位的生成过程
  $c_{i+1}=(a_i\And b_i)|(a_i\And c_i)|(b_i\And c_i)=(a_i\And b_i) |(a_i|b_i)\And c_i=g_i \| p_i\And c_i $
- 记$g_i=a_i\And b_i$ 进位生成因子(g=1则$c_{i+1}$输出为1)
- $p_i=a_i\|b_i$ 进位传递因子(p=1则$c_{i+1}$输出为$c_i$输入)
- 以4位为例，展开公式：
 $c_1=g_0|p_0\And c_0$
 $c_2=g_1|p_1\And (g_0|p_0\And c_0)=g_1|p_1\And g_0|p_1\And p_0\And c_0$
 $c_3=g_2|p_2\And g_1|p_2\And p_1\And g_0|p_2\And p_1\And p_0\And c_0$
 $c_4=g_3|p_3\And g_2|p_3\And p_2\And g_1|p_3\And p_2\And p_1\And g_0|p_3\And p_2\And p_1\And p_0\And c_0$
- 据此画出进位逻辑电路

![4位先行进位加法器](/assets/ca/第八章图/块内并行的4位先行进位加法器.png)
- 产生$c_4$只需要2级门延迟，再加上生成PG的1级门
- 但是每个门都变复杂了
  - 会有5输入的与非门
  - 实际上5输入门不常用
  - 计算时按照1级门来算

![5输入与非门](/assets/ca/第八章图/5输入与非门.png)

#### 使用进位逻辑搭建加法器
- 使用进位逻辑生成进位
  - 输入为$p_i$、$g_i$，输出为$c_i$
- 只需要全加器的S输出，不再需要$C_{out}$输出

![进位逻辑加法器](/assets/ca/第八章图/并行加法器.png)

#### 更多位数的加法器
- 块内并行块间串行(16位加法器)

![16位加法器](/assets/ca/第八章图/16位并行加法器.png)
- 将进位逻辑接上全加器
- 16位加法器延迟
  - 1(产生pg)+$2\times4$(生成进位)+3(生成$S_{15}$)=12级门
- 16位行波进位加法的延迟
  - 33级门

#### 更快的进位
- 块内并行块间并行
  - 块内并行时，有进位传递信号p和g
  - 所以块间并行需要块间进位传递信号P和G
  - 定义：
    - 当G=1时，**本块**有进位输出
    - 当P=1时，**本块**进位输出依赖于本块的进位输入
    - $P=p_3\And p_2\And p_1\And p_0$
    - $G=g_3\|p_3\And g_2\|p_3\And p_2\And g_1\|p_3\And p_2\And p_1\And g_0$
- 块间并行进位逻辑

![块间并行进位逻辑1](/assets/ca/第八章图/块间并行进位逻辑.png)
- 自下而上形成$p_ig_i$，自上而下形成$c_i$
- 共6级门延迟：
  - 第一层pg，第二层c($c_4,c_8,c_{12}$)，第一层c($c_1,c_2,c_3,c_5,...$)

![块间并行进位逻辑2](/assets/ca/第八章图/块间并行进位逻辑2.png)
- 计算进位逻辑延迟
  - 生成P和G需要2级门
  - 生成上层的$c_{1-3}$需要2级门
  - 生成下层的每个$c_{1-3}$再需要2级门
  - 总共6级门，最大的门为4输入与非门

#### 更大的加法器
- 64位处理器中常用的64bit的加法
  - 还使用4bit进位逻辑
  - 使用3层结构搭建进位逻辑
- 共10级门延迟
  - 第一层pg，第二层pg，第三层c($c_{16},c_{32},c_{48}$)，第二层c($c_4,c_8,c_{12},c_{20},...$)，第一层c($c_1,c_2,c_3,c_5,... $)

![64位加法器](/assets/ca/第八章图/64位加法器.png)
## 减法运算实现
### 补码减法算法
- $[A-B]_{补}=[A]_{补}-[B]_{补}=[A]_{补}+[-B]_{补}$
- $[A]_{补}-[B]_{补}=[A]_{补}+[B]_{补}按位取反+1$
  - A+B型加法器的$c_0$刚好是空闲的
- 使用SUB信号，设计加减法器

![减法器](/assets/ca/第八章图/减法器.png)
### 溢出判断
