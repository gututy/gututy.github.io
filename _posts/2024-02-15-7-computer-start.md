---
title: 计算机系统启动过程分析
tags: 计算机体系结构 学习笔记
permalink: /notes/ca/computer-start
aside:
    toc: ture
sidebar:
    nav: notes
---

> 第七章：计算机启动过程分析
<!--more-->

# 一句话要点
```markdown
- 系统启动
  - 从复位到系统可用
- 初始化是什么
  - 将系统各种寄存器状态从不确定设置为确定，将一些模块状态从无序强制为有序的一个过程
- 什么东西需要初始化
  - CPU、内存、各类IO接口
- 怎么初始化
  - 按照从核内到核外，从片内到片外的次序进行
```
![系统启动](/assets/ca/第七章图/系统启动.png)

# 处理器核初始化
## 处理器复位
- 从芯片引脚输入电平信号，将处理器内部的部分寄存器等状态置为预设值
  - 开始取指(LoongArch 处理器的第一条指令为0x1C000000)
- 复位输入是一个硬件初始化动作，至少需要完成最基本的芯片状态初始化(保证第一条指令取指执行)
  - 控制寄存器状态初始化，如处于核心态
  - 核内程序计数器(PC)初始化为0x1C000000
  - 片内对于0x1Cxxxxxx段地址的路由通路初始化
  - 清空流水线有效位避免混乱
  - **为什么不初始化更多硬件？**
    - 减轻软件负担，缩短系统启动时间，将更多硬件交由硬件自动处理
- 复位后，CPU内部只有取指通路一丝光亮，其余漆黑一片

### 首条指令
- 初始化控制器存期(用于控制处理器行为，如中断)
  - 模式信息CRMD(0x0)
  - 例外配置ECFG(0x4)
  - 例外入口地址EENTRY(0xC)
  - TLB重填例外入口地址TLBRENTRY(0x88)
- 初始化软件约定使用的通用寄存器
  - 栈指针：BIOS用的堆栈
  - 全局指针：BIOS用的地址空间
  - Stack、_gp为代码标号，编译时使用实际地址替换

```nasm
;手写代码
dli       t0, (0x7 << 16)
csrxchg   zero, t0, 0x4       ;设置中断入口间距
dli       t0, 0x1c001000
csrwr     t0, 0xc             ;设置普通例外入口地址
dli       t0, 0x1c001000
csrwr     t0, 0x88            ;设置TLB重填例外入口地址
dli       t0, (1 << 2)
csrxchg   zero, t0, 0x0       ;关中断执行
la        sp, stack           ;初始化栈指针

la        gp, _gp             ;初始化全局指针
```
```nasm
;编译器代码
lu12i.w       $r12, 0x70
csrxchg       $r0, $r12, 0x4
lu12i.w       $r12, 0x1c001
csrwr         $r12, 0xc
lu12i.w       $r12, 0x1c001
csrwr         $r12, 0x88
ori           $r12, $r0, 0x4
csrxchg       $r0, $r12, 0x0
lu12i.w       $r3, 0x90400
lu32i.d       $r3, 0
lu52i.d       $r3, $r3, 0x900
lu12i.w       $r2, 0x90020
ori           $r2, $r2, 0x900
lu32i.d       $r2, 0
lu52i.d       $r2, $r2, 0x900
```

### 模式信息控制寄存器
- 四种特权等级，CRMD(0x0)
  - 复位后默认为最高特权等级
![CRMD.PLV](/assets/ca/第七章图/CRMD.PLV.png)
- 例外使能控制，CRMD(0x0)
![CRMD.IE](/assets/ca/第七章图/CRMD.IE.png)

### 例外相关控制寄存器
- 例外入口支持向量化，ECFG(0x4)
  - VS=0，使用统一入口
![ECFG.VS](/assets/ca/第七章图/ECFG_VS.png)
- 例外入口地址，EENTRY(0xC)
![EENTRY](/assets/ca/第七章图/EENTRY.png)
- TLB重填例外入口地址，TLBENTRY(0x88)
![TLBENTRY](/assets/ca/第七章图/TLBENTRY.png)

## 外部调试接口初始化
> - 外部调试接口本身不是处理器核初始化的内容，但调试时需要尽早开始人机交互，方便软件调试
> - 输出
>   - 蜂鸣器
>   - 数码管显示
> - 输入输出
>   - 串口控制器
> - 显示器这样的设备相比执行是比较复杂的接口，在启动的后期才会使用

### 串口初始化
- 建立主机与被调试机之间的通信协议
  - 其中GS3_UART_BASE是串口控制器内部的寄存器
- **所谓驱动就是读写IO设备控制器**
  - **注意读写IO设备与读写存储器的不同**
```nasm
LEAF(inintserial)
li      a0, GS3_UART_BASE       ;加载串口设备基地址

li      t1, 128                 ;线路控制寄存器，写入0x80(128)表示后续的寄存器访问为分频寄存器
sb.b    t1, a0, 3               ;寄存器访问

li      t1, 0x12                ;配置串口波特率分频，当串口控制器输入频率为32MHz，并将串口通信
sb.b    t1, a0, 0               ;速率设置为115200时，分频方式为33000000/16/0x12=114583
li      t1, 0x12                ;由于串口通信有固定的起始格式，能够容忍传输两端一定的速率差异，
sb.b    t1, a0, 1               ;只要将传输两端的速率保持在一定范围内就可以保证传输的正确性

li      t1, 0x3
sb.b    t1, a0, 3               ;设置传输字符宽度为8，同时将后续的寄存器访问设置为正常寄存器

li      t1, 0
sb.b    t1, a0, 1               ;不使用中断模式

li      t1, 71
sb.b    t1, a0, 2
jirl    ra
END(initserial)
```

- 部分寄存器定义

![串口初始化寄存器1](/assets/ca/第七章图/串口初始化1.png)
![串口初始化寄存器2](/assets/ca/第七章图/串口初始化2.png)

#### 串口字符输入输出
```nasm
字符输出
LEAF(tgt_putchar)
dli     a1, GS3_UART_BASE       ;加载串口设备基地址
1:
ld.bu   a2, a1, 0x5             ;读取线路状态寄存器中的发送FIFO空标志
andi    a2, a2, 0x20
                                ;FIFO非空时等待
beqz    a2, 1b                  ;FIFO空时将通过a0传入的字符写入数据寄存器
st.b    a0, a1, 0
jirl    zero, ra, 0
END(tgt_putchar)
```
```nasm
字符输入
LEAF(tgt_getchar)
dli     a0, GS3_UART_BASE       ;加载串口设备基地址
1:
ld.bu   a1, a0, 0x5             ;读取线路状态寄存器中的接收FIFO有效标志
andi    a1, a1, 0x1
                                ;接收FIFO为空时等待
beqz    a1, 1b                  ;FIFO非空时将数据读出并放在a0寄存器中返回
ld.b    a0, a0, 0
jirl    zero, ra, 0
END(tgt_getchar)
```

## TLB初始化
- TLB用于虚实地址转换
- 从TLB来看，LoongArch的地址空间分为窗口映射和TLB映射
  - 在窗口映射中命中的地址使用窗口直接映射的方式
  - 其他未命中的地址全部使用TLB映射
  - **对于BIOS，基本使用非映射空间，无需TLB转换**
- 对于特别的地址转换需求，会借助TLB映射
  - 0xC0000000→0x40000000：对应显存等大IO空间

### LoongArch的虚拟地址空间
![LoongArch虚拟地址空间](/assets/ca/第七章图/LoongArch虚拟地址空间.png)

### TLB初始化代码
- 逐一清空每一个TLB项
  - 需要使用时再填入正确映射(**通过TLB Refill例外**)
- LoongArch中支持更简洁的初始化指令
  - INVTLB 0
- 越来越多的处理器不再需要软件初始化TLB

```nasm
LEAF(CPU_TLBClear)
dli     a3, 0                       ;循环控制变量
dli     a0, (1<<31) | (12<<24)      ;设置页大小为4K，31位为1表示无效
li      a2, 64                      ;TLB表项树
1:
csrwr   a0, 0x10                    ;将表项写入编号为0x10的TLBIDX寄存器
addi.d  a0, 1                       ;增加TLBIDX中的索引号
addi.d  a3, 1                       ;增加循环变量
tlbwr                               ;写TLB表项
bne     a3, a2, 1b
jirl    zero, ra, 0
END(CPU_TLBClear)
```
- TLB表项
  - 全相联
  - 32-64项
  - **关注E这一项**

![TLB表项](/assets/ca/第七章图/TLB表项(7).png)

- TLB控制寄存器
  - **关注NE这一项**

![TLB控制寄存器](/assets/ca/第七章图/TLB控制寄存器.png)
![TLB控制寄存器2](/assets/ca/第七章图/TLB控制寄存器2.png)

## Cache初始化
- 复位后BIOS刚开始启动时，处理器从非缓存空间开始执行
  - **上千拍**完成一条指令的取指和执行
  - Cache初始化后，跳转到Cache空间执行，全速流水
  - 尽早完成Cache初始化，使用Cache地址执行能够大大提升启动速度
- 从Cache来看，逻辑地址空间分为非缓存和缓存
  - LoongArch使用窗口进行映射，一般情况下按以下的设置方式
  - 0x90000000_00000000 - 0x9FFFFFFF_FFFFFFFF ：Cache访问方式
  - 0x80000000_00000000 - 0x8FFFFFFF_FFFFFFFF ：Uncache访问方式
  - 上述两个通过窗口来映射的空间，虽然访问的方式不同，但后面所映射的物理地址是相同的。区别在于用Cache方式访问时，如果在Cache中失效会自动到实际的物理位置取回数据；而用Uncache方式，则不会在Cache中查找。Uncache一般用于IO访问
  - 为什么用一个Cache地址进行写操作后，用同样的Uncache地址无法得到写入的值？
  
### 一级Cache初始化代码
```nasm
LEAF(godson2_cache_init)
li        a2, (1<<14)       ;64KB/4路，为Index的实际数量
li        a0, 0x0           ;a0表示当前的Index
1:
CACOP     0x0, a0, 0x0      ;对4路Cache分别进行写TAG操作
CACOP     0x0, a0, 0x0
CACOP     0x0, a0, 0x0
CACOP     0x0, a0, 0x0
addi.d    a0, a0, 0x40      ;每个Cache行大小为64字节
bne       a0, a2, 1b
jirl      ra
END(godson2_cache_init)
```
- 片上Cache容量越来越大，使得初始化事件越来越长
- 使用硬件资源在复位时对TLB、Cache等结构的初始化
  - 大幅减少系统启动的时间
  - 龙芯3A2000以后的处理器都支持硬件初始化Cache

### Cache指令及寄存器
- Cache在功能上对用户程序是透明的，但对OS是可见的
  - 以前硬件一般不对Cache做初始化，刚上电时Cache内容是乱的
  - 需要软件把Cache初始化成任何访问都不命中
- LoongArch的Cache指令，只能在核心态下使用
  - LoongArche的Cache指令通过OPCODE来表示具体的操作
  - 包括初始化和维护一致性的操作

### Cache算法配置
- 两位决定Cache算法
  - 0-Uncached、1-Cached、2-Uncache ACC
  - 对于窗口映射方式，由窗口配置寄存器的MAT域决定
  - 其他部分由TLB表项决定

![Cache算法1](/assets/ca/第七章图/Cache算法1.png)
![Cache算法2](/assets/ca/第七章图/Cache算法2.png)

## 处理器核初始化后
CPU内部一片光亮，除了串口和BIOS接口，多数“门窗”都没开

# 总线接口初始化
## 内存接口初始化
- 到此为止，BIOS从Flash读程序，写IO或控制寄存器
  - 相比Flash设备，内存接口的访问性能大大提升
- 内存接口的初始化与核内部件的初始化的差别
  - Cache/TLB的初始化主要是将内容设置为无效
  - 内存接口的初始化针对接口控制
- 内存接口初始化内容
  - 通过内存的SPD(并非必需)获取内存大小，类型，频率，延迟等各种信息
  - 根据所得到的内存信息对控制器和内存进行设置
  - 可能还有对于时序配合的信号训练
  - 对内容并不关心(ECC内存除外，不初始化内容会导致ECC错)

### 内存控制器配置代码
- 将预先定义好的值写入内存控制器的相应寄存器中
- 内存控制器将自动对内存进行初始化配置
  - 主要设置延迟、匹配阻抗等
- 初始设置后，会再对内存信号进行训练

```nasm
ddr2_config:
  add.d     a2, a2, s0          ;a2为调用该程序时传入的参数，与s0之和用于表示初始化参数在FLASH中的基地址
  dli       t1, DDR_PARAM_NUM   ;t1用于表示内存参数的个数
  addi.d    v0, t8, 0x0         ;t8用于表示内存参数的个数
1:
  ld.d      a1, 0x0(a2)         ;初始化的过程就是从FLASH中取数再写入内存控制器中的寄存器的过程
  st.d      a1, 0x0(v0)         
  addi.d    t1, t1, -1
  addi.d    a2, a2, 0x8
  addi.d    v0, v0, 0x8
  bnez      t1, 1b
```

## IO总线初始化
- 根据不同IO总线的需求进行针对性的初始化
- 通过初始化配置消除与具体实现相关的总线特性，保证软件兼容性
  - 信号定义，硬件实现各不相同：HyperTransport、PCIE等
  - 软件协议兼容PCI：配置空间、IO空间及Memory空间
- 龙芯3号中使用HyperTransport接口
  - 地址划分：确定配置访问、IO访问及Memory访问的地址
  - 设定DMA访问地址
  - 对总线频率、宽度进行重新设置

## 总线接口初始化后
- CPU内部一片光亮，“门窗”也已打开
- 但窗外还是一片漆黑

# 设备探测及驱动加载
## PCI协议下的工作流程
- 上世纪九十年代提出，软件结构被PCIE和HT等继承
  - 配置空间、IO空间、Memory空间
- 通过配置空间探测总线设备
  - 配置空间大部分情况下是对设备的属性进行刻画
  - 在完成设备探测之后基本不再使用配置空间
- 对总线上的各个设备所需的地址空间进行分配
  - IO、Memory空间是真正使用设备功能时的地址空间
  - 对于IO和内存统一编址的CPU，两者区别不大
- 使用分配好的空间对各个设备进行控制
  - 主要是驱动程序加载
- 特点：
  - 总线设备发生变化时无需修改软件
  - 同一总线支持多个相同设备不会导致冲突

## 设备探测
- 使用配置空间：以HT的配置空间为例
  - 高位地址访问不同设备，FDFE和FDFF是HT协议规定的
  - 通过总线号、设备号及功能号可以遍历总线设备
  - Offset是设备内地址偏移，索引设备空间寄存器
   ![HT总线配置访问](/assets/ca/第七章图/HT总线配置访问.png)
  - 通过规定的寄存器得到设备的唯一标识、设备类型等
    - Device ID、Vendor ID
  - 通过基址寄存器(BAR)获取并对设备空间进行配置
    - IO设备需要使用的内存空间

### 设备配置空间寄存器分布
- 一般放在IO控制器上(如PCIE控制器)
  - 所有设备的空间分布都一致
  - Vender ID(厂商识别号)：Intel为0x8086，龙芯为0x0014
  - Device ID(设备识别号)：为全0或全1表示没有设备

![设备配置空间寄存器分布](/assets/ca/第七章图/设备配置空间寄存器分布.png)

### 地址空间分配
- 基址寄存器(BAR)
  - 向该寄存器写入全1，读出再判断0的个数来获取空间需求
  - 再向该寄存器写入分配好的基地址供设备进行命中判断
  - ![地址空间分配](/assets/ca/第七章图/地址空间分配.png)
- 每个设备地址空间为2的幂次方对齐
- 先收集所有的设备空间信息
  - 按照大小排序
  - 根据顺序分配基地址，以减少空间碎片

### PCI设备的探测
1. 将初始总线号、初始设备号、初始功能号设为0
2. 使用当前的总线号、设备号、功能号组成一个配置空间地址，这个地址的构成如[设备探测](#设备探测)的图所示，使用该地址访问其0号寄存器，检查其设备识别号
3. 如果读出全1或全0，表示无设备
4. 如果该设备为有效设备，检查每一个BAR所需空间的大小，并收集相关信息
5. 检测其是否为多功能设备，如果是则将功能号加1重复扫描，执行第2步
6. 如果该设备为桥设备，则给该桥配置一个新的总线号，再使用该总线号，从设备号0、功能号0开始递归调用，执行第2步
7. 如果设备号非31，则设备号加1继续执行第2步；如果设备号为31，且总线号为0，表示扫描结束；如果总线号非0，则退回上一层递归调用

### PCI设备探测过程
- 对多功能设备扫描FUNC
  - 可以有更多的地址空间BAR
- 对桥设备递归调用该过程
  - 如南桥上有很多设备
- 遍历整个总线获得所有设备信息
  - 同时对设备地址空间大小进行排序
- 再次遍历对每个设备空间进行配置
  - 把设备地址空间的信息传递给设备驱动程序，设备驱动程序使用配置好的设备地址空间

![PCI设备探测过程](/assets/ca/第七章图/PCI设备探测过程.png)

### 地址空间分配示例
- 设备内部的地址空间，CPU通过Uncache或IO指令访问
- 配置空间扫描后得到的设备空间需求
- ![地址空间分配示例1](/assets/ca/第七章图/地址空间分配示例1.png)
- 最终的地址空间分配
- ![地址空间分配示例2](/assets/ca/第七章图/地址空间分配示例2.png)

# 多核启动过程
## 多核初始化
- 一个核执行主流程，其他核仅负责私有部件的初始化
  - 主核：核内私有部件、片内共享部件、总线接口
  - 从核：核内私有部件
- 通过核间通信机制进行同步
  - 串口初始化后，通知从核，开始打印输出
  - 共享Cache初始化后，通知从核，开Cache执行
  - 内存初始化后，通知从核，可以读写内存
- 可以通过并行化共享部件初始化的方法来加速启动
  - 每个核初始化一部分共享Cache
  - 每个核执行不同的初始化：Cache、内存、接口
## 核间通信机制
- 核间**中断**机制，以龙芯3A为例
  - 每个核有32个不同的中断可供软件使用
  - 可以约定为不同核产生的中断，或者对应不同事件
- 信箱寄存器(**查询**方式)
  - 多个寄存器供传递参数及特殊事件

|名称|读写权限|描述|
|:-----|:-----|:-----|
|IPI_Status|R|32位状态寄存器，被置1且对应位使能情况下，处理器核中断线被置位|
|IPI_Enable|RW|32位使能寄存器，控制对应中断位是否有效|
|IPI_Set|W|32位置位寄存器，往对应的位写1，则对应的STATUS寄存器位被置1|
|IPI_Clear|W|32位清除寄存器，往对应的位写1，则对应的STATUS寄存器位被清0|
|MailBox0|RW|缓存寄存器，供传递参数使用|
|MailBox01|RW|缓存寄存器，供传递参数使用|
|MailBox02|RW|缓存寄存器，供传递参数使用|
|MailBox03|RW|缓存寄存器，供传递参数使用|

## 多核唤醒
- 内核启动过程中，会将从核逐一加入系统管理
  - 这一过程称之为“唤醒”
- 唤醒中主从核的运行
  - 主核：将从核需要运行的程序指针、参数写入信箱寄存器，等待从核被唤醒
  - 从核：轮询信箱寄存器，发现非零值则跳转执行，执行完相关的程序后，通过信箱寄存器通知主核
  - 主核：收到信箱寄存器通知后，继续下一个核的唤醒或其他操作

<details>
<summary>唤醒代码</summary>
<div markdown="1">

```nasm
slave_main:
  dli     t2, NODE0_CORE0_BUF0          ;NODE0_CORE0_BUF0为0号核的信箱寄存器地址，其他核的信箱
  dli     t3, BOOTCORE_ID               ;寄存器地址与之相关，在此根据主核的核号，确定主核信箱的
  sll.d   t3, 8                         ;实际地址
  or      t2, t2, t3

wait_scache_allover:
  ld.w    t4, t2, FN_OFF                ;等待主核写入初始化完成标志
  dli     t5, SYSTEM_INIT_OK
  bne     t4, t5, wait_scache_allover   

  bl      clear_mailbox                 ;对每个核各自的信箱寄存器进行初始化

waitforinit:
  li      a0, 0x1000
idle1000:
  addiu   a0, -1
  bnez    a0, idle1000

  ld.w    t2, t1, FN_OFF                ;t1为各个核的信箱寄存器地址，轮询等待
  beqz    t2, waitforinit

  ld.d    t2, t1, FN_OFF                ;通过读取低32位确定是否写入，再读取64位得到完整地址
  ld.d    sp, SP_OFF(t1)                ;从信箱寄存器中的其他地方取回相关启动参数
  ld.d    gp, GP_OFF(t1)
  ld.d    a1, A1_OFF(t1)

  move    ra, t2                        ;转至唤醒地址，开始执行
  jirl    zero, ra, 0x0
```
</div>
</details>

--------------

- BIOS完成上述工作后
  - 从硬盘把内核取到内存(DMA或PIO)，并跳转到内核地址，由内核负责后续计算机控制
    - BIOS要把基本的硬件参数通过BIOS与内核接口(如ACPI接口)传递给内核
    - Intel定义的UEFI和ACPI接口是保证PC跨代兼容的重要原因
  - 内核根据预设的(如启动X系统)或临时的(如打开PPT)用户需求，把相关程序取到内存执行
    - 内核通过进程方式调度CPU，通过虚拟存储管理管内存，通过设备驱动管IO

# 小结
- CPU刚上电时，硬件只对必要的状态进行复位
  - 除了从PC到BIOS接口有一丝光亮，其它都是漆黑一片
  - 从0x1C000000取第一条指令时要绕过Cache和TLB
- 软件初始化必要的调试接口：指示灯、蜂鸣器、串口
  - 从SPI接口（约为33MHz）取指，每拍一位，32拍才取回一条指令，CPU要1000拍才执行一条指令；CPU内部有些朦胧的光亮
  - Load/Store指令访问IO接口的控制寄存器与访问内存有不同的含义
- 软件初始化CPU内部
  - 打开TLB，访问地址空间更大；初始化Cache，CPU可以高速运行
  - CPU内部一片光明，但外部还是漆黑一片
- 软件初始化内存控制器
  - 通过I2C总线读取内存条信息
  - 内存控制器参数太多，主要是从BIOS空间读取内存参数并写入内部控制寄存器
  - DDR4 3200每传输一位数据只有0.3ns，电信号只能在主板上行进4-5cm
  - 内存是CPU的后花园，这时CPU通往后花园的路已经打通
- 软件初始化IO接口
  - PCI协议：上世纪九十年代提出，软件结构被PCIE和HT等继承
  - 配置空间：通过配置空间探测总线设备，配置空间大部分情况下是对设备的属性进行刻画；CPU通过对设备空间的扫描发现所有IO控制器；
  - IO空间、Memory空间：驱动程序真正使用设备功能时的地址空间；对于IO和内存统一编址的CPU，两者区别不大；
  - 总线设备发生变化时无需修改软件，同一总线支持多个相同设备不会导致冲突
  - Intel的厉害之处：PCI协议使得硬件能自动识别IO设备并加载驱动程序；UEFI协议使得最新的CPU可以运行十年前的操作系统；X86指令系统使得最新的CPU可以运行几十年前的应用程序
- 唤醒其它处理器核，进入多核状态
  - 多核之间通过信箱等方式通信
  - 信箱可以是内存单元，也可以是CPU内部寄存器
- 至此，CPU内部光明一片，对外四通八达


