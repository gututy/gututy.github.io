---
title: 计算机总线接口技术
tags: 计算机体系结构 学习笔记
permalink: /docs/ca/bus
aside:
    toc: ture
sidebar:
    nav: computer_architecture
---

# 计算机总线接口技术
## 总线概述
- 总线是什么
  - 链接计算机各部件，用于数据传送的通讯系统
  - 本质作用是**进行数据交换**
- 为了让不同厂家生产的部件相互匹配
  - 形成总线规范
  - 兼容性认证
- 总线规范包括以下层次：
  - 机械层：接口的外形、尺寸、信号排列、连接线的长度范围等
  - 电器层：信号描述、电源电压、电平标准、信号质量等
  - 协议层：信号时序、握手规范、命令格式、出错处理等
  - 架构层：硬件模型、软件架构等

## 总线分类
- 按照数据传递方向
  - 单向总线
    - A→B单向传
    - VGA、DVI
  - 双向总线
    - 半双工总线(只有一个数据传输通道)
      - 同时只能进行一个方向的传送，A→B或B→A
      - USB 2.0
    - 全双工总线(有两个数据传输通道)
      - 同时可以进行两个方向的传送，A→B和B→A
      - UART

- 按总线使用的信号类型(数据组织方式)
  - 并行总线
    - 多字节同时传，相同频率下总线的带宽更大
    - 需控制线间的延迟差
    - 线多之后提升频率困难
    - PCI、HT、DDR
  - 串行总线
    - 字节按位传
    - 多条线之间无等长要求
    - USB、SATA、PCIe

- 按数据握手方式
  - 无
    - 发送端总在发，接收端无条件接收
    - DVI、APB
  - Valid-Ready
    - 发送端、接收端都有“准备好”标识
    - 两边都准备好才能传输
    - PCI、AXI
  - Credit
    - 发送端跟踪接收端的可用缓冲数
    - 发送前先判断是否能够接收
    - PCIe、HT
  
![数据握手](/assets/ca/第六章图/总线分类_数据握手.png)

- 按连接方式
  - 共享信号
    - 同一组信号线
    - 通过仲裁占有总线
    - 三态输出(高、低、高阻)
    - PCI

![共享信号](/assets/ca/第六章图/总线分类_连接方式_共享信号.png)

  - 点对点
    - 独占信号线
    - 专用的交换节点
    - PCIe

![点对点](/assets/ca/第六章图/总线分类_连接方式_点对点.png)

- 按时钟实现方式
  - 全局时钟
    - 时钟源到各部件路径等长
    - PCI
  - 源同步
    - 时钟随数据一起发送
      - 时钟数据传输路径等长
      - HT
    - 时钟嵌入到数据中发送
      - 对发送的数据进行编码
      - 从接收数据中恢复时钟
      - PCIe

![时钟实现](/assets/ca/第六章图/总线分类_时钟实现.png)

- 按总线实现位置
  - 片上总线
  - 内存总线
  - IO总线

## 片上总线
- 芯片内部模块互连使用的总线
  - 处理器核
  - 内存控制器
  - IP核
- 支持基本的读写操作
  - 将读写请求按地址送到目标模块
  - 将读写相应返回到发起模块
- 设计空间
  - 系统性能
  - 实现代价、复杂性
- 与片外实现相比
  - 引线资源丰富
  - 全局时钟相对容易实现
  - 不需要复杂的物理层转换
  - 不使用三态信号
- 基本连接单元
  - buffer
   ![buffer](/assets/ca/第六章图/片上总线_单元1.png)
  - mux
   ![mux](/assets/ca/第六章图/片上总线_单元2.png)

![点对点式的共享信号链接](/assets/ca/第六章图/片上总线_点对点.png)

- 性能
  - 相关因素
    - 频率：能跑多快
      - 能否加流水级，加多少
    - 数据位宽：单位周期传送的数据量
      - 8/16/32/64/128/256/512...
    - 带宽利用率：总线事务中数据传输时间占总时间的平均值
      - 读：主设备发出读请求到设备，准备数据，通过总线返回
      - 写：主设备发出写请求到从设备，接收数据，返回状态
      - 延迟不容易降低，关键是能否流水，支持outstanding
      - 同时进行中的总线事务个数
  - 性能目标决定了实现代价
---
- AMBA(Advanced Microcontroller Bus Architecture,高级微控制器总线架构)
  - 开放标准，广泛应用于SoC、ASIC、AP

![片上总线分类对比](/assets/ca/第六章图/片上总线_分类对比.png)

### APB总线(本地二级总线)
- 特点
  - 单主设备
  - 共享式
  - 片选

![APB总线](/assets/ca/第六章图/APB总线.png)

  - 固定时序，不支持突发
  - 没有数据握手，无法插入等待周期
  - 接口简单易实现

![APB总线写](/assets/ca/第六章图/APB总线写.png)
写

![APB总线读](/assets/ca/第六章图/APB总线读.png)
读

### AHB总线(高性能系统总线)
- 特点
  - 中央仲裁器(Arbiter)、译码器(Decoder)
  - 共享式总线
  - 片选

![AHB总线1](/assets/ca/第六章图/AHB总线1.png)

![AHB总线2](/assets/ca/第六章图/AHB总线2.png)

  - 无独立的请求/数据通道
  - 支持突发传输，数据周期落后地址周期一拍
  - 主设备、从设备均可插入等待周期
  - 事务分割、流水线操作、单周期总线主设备切换、非三态实现、宽数据总线

![AHB事务](/assets/ca/第六章图/AHB事务.png)

### AXI总线
#### 架构
- 由五个通道组成
  - 写地址、写数据、写响应
  - 读地址、读返回
- 基本定义
  - 总线事务(transaction)：
    - 一次完整的读写过程
  - 传输(transfer)：
    - 传输一个周期的数据
    - 在VALID、READY同期为高的周期完成一次传输

![AXI架构](/assets/ca/第六章图/AXI架构.png)

#### 事务示例
- 读

![AXI读](/assets/ca/第六章图/AXI事务_读.png)

- 重叠读

![AXI重叠读](/assets/ca/第六章图/AXI事务_重叠读.png)

- 写

![AXI写](/assets/ca/第六章图/AXI事务_写.png)

#### 关键信号
- ID：支持读写乱序
  - 每个事务都有ID标签(ARID/RID/AWID/WID/BID)
  - 同ID的事务必须按序
  - 不同ID的事务可以乱序
- BURST/LEN/SIZE：突发传输控制
  - 突发传输类型：FIXED, INCR, WRAP
  - 突发传输长度：1\~16
  - 突发传输单位(宽度)：1, 2, 4\~BW
- WSTRB：写掩码
  - 为高时的位对应的字节写有效
- RESP：读/写响应状态
- ARLOCK/AWLOCK：原子性操作
  - 00：普通
  - 01：独占
    - 独占地对某个地址先读后写，若期间没有其他主设备写，则成功写入，否则失败，通过RESP返回状态，类似LL/SC
  - 10：加锁
    - 从第一个加锁事务开始，到第一个普通事务结束
    - 将所访问的从设备区域加锁，阻止其他主设备访问
- ARPROT/AWPROT：访问保护
  - [0]：普通/特权
  - [1]：安全/非安全
  - [2]：数据/指令
- ARCACHE/AWCACHE：缓存控制
  - [0]：可写缓冲，未达到目的即回响应
  - [1]：可缓存，cached/uncached，读预取，写合并
  - [2]：读分配，如果读发生缓存缺失则分配一个缓存块
  - [3]：写分配，如果写发生缓存缺失则分配一个缓存块
#### 互连
- 将多个主设备、从设备相连
  - AML：单主接多从
    - 根据地址路由
  - ASL：多主接单从
    - ID域扩展，加上主端口号
    - 返回时选择路由
  - 共享式
    - 互连线少
  - 交换式
    - 带宽高

![AXI互连](/assets/ca/第六章图/AXI互连.png)

#### AXI实例(研讨课相关)

<details>
  <summary>test</summary>

{% highlight c %}
int a = 1;
{% endhighlight %}
</details>

<details>
  <summary>详情</summary>

- 设计一个AXI接口的RAM
  - 容量64KByte
  - 数据宽度128bit
  - 不考虑prot/cache/lock
- 要求
  - 充分发挥AXI总线的优势
  - 达到200%带宽利用率(读100%+写100%)

{% highlight verilog %}
module axi_ram(
    input           aclk,
    input           aresetn,

    input[3:0]      s_awlen,
    input[7:0]      s_awid,
    input[31:0]     s_awaddr,
    input[2:0]      s_awsize,
    input[1:0]      s_awburst,
    input           s_awvalid,
    output          s_awready,

    input[7:0]      s_wid,
    input[127:0]    s_wdata,
    input[15:0]     s_wstrb,
    input           s_wlast,
    input           s_wvalid,
    output          s_wready,

    output[7:0]     s_bid,
    output[1:0]     s_resp,
    output          s_bvalid,
    input           s_bready,

    input[3:0]      s_arlen,
    input[7:0]      s_arid,
    input[31:0]     s_araddr,
    input[2:0]      s_arsize,
    input           s_arvalid,
    output          s_arready,

    output[7:0]     s_rid,
    output[127:0]   s_rdata,
    output[1:0]     s_rresp,
    output          s_rlast,
    output          s_rvalid,
    input           s_rready,
);
{% endhighlight %}

- 思路
  - 充分流水，避免时序瓶颈
  - 多体实现，增加读写并行度

![AXI设计思路](/assets/ca/第六章图/AXI设计思路.png)

  - 读写命令缓冲及拆分
    - 存储AXI总线的访问请求，并将Burst长度大于1的访问拆分位多周期访问，往后级转发。读和写访问的拆分同时进行，如果不发生冲突，则读写可一起前进
  - 读写控制分发
    - 进行地址译码，产生对应RAM块的访问信号
  - RAM访问
    - RAM访问需要1周期
  - RAM读出数据缓冲
    - 传递RAM的输出结果以及读写的ID信息
  - 输出缓冲
    - 产生R\*和B\*两组输出。输出缓冲没有空项作为流水线停顿的控制信号
    - 冲突检测只在第一季流水完成，为避免由于读写不同步而导致新的冲突，读写流水之间采用相同的控制信号。即如果写回应被堵住，读数据返回也将停止，反之亦然

- 读缓冲设计

{% highlight verilog %}
wire            rd_accept;//accept ar request
wire            rd_issue;//read addr gen
always @(posedge aclk) begin
    if (areset) begin
        rbuf_busy <= 1'b0;
        rbuf_len  <= 4'b0;
    end
    else begin
        if (rd_accept) begin
            rbuf_busy <= 1'b1;
            rbuf_addr <= s_araddr;
            rbuf_len  <= s_arlen;
            rbuf_size <= s_arsize;
            rbuf_id   <= s_arid;
            rbuf_wrap <= (s_arburst == 2'b10) && (s_araddr[4:0] == 5'b10000) & (s_arlen == 4'b1);
        end
        else if (rd_issue) begin
            rbuf_busy <= (rbuf_len != 4'b0);
            rbuf_len  <= rbuf_len - 4'b1;
            rbuf_addr <= rbuf_wrap ? rbuf_addr - 5'h10 : rbuf_addr + 5'h10;
        end
    end//else: !if(areset)
end
{% endhighlight %}

- 写缓冲设计

{% highlight verilog %}
wire            wr_accept;// accept aw request
wire            w_accept; // accept w request
wire            wr_issue; // write addr gen
always @(posedge aclk) begin
    if (areset) begin
        wbuf_busy   <= 1'b0;
        wbuf_len    <= 4'b0;
        wdata_valid <= 1'b0;
    end 
    else begin
        if (wr_accept) begin
            wbuf_busy <= 1'b1;
            wbuf_addr <= s_awaddr;
            wbuf_len  <= s_awlen;
            wbuf_size <= s_awsize;
            wbuf_id   <= s_awid;
            wbuf_wrap <= (s_awburst == 2'b10) && (s_awaddr[4:0] == 5' b10000) & (s_awlen == 4'b1);
        end
        else if (wr_issue) begin
            wbuf_busy <= (wbuf_len != 4'b0);
            wbuf_len  <= wbuf_len - 4'b1;
            wbuf_addr <= wbuf_wrap ? wbuf_addr - 5'h10 : wbuf_addr + 5'h10;
        end

        wdata_valid <= w_accept | wdata_valid & ~wr_issue;
        if (w_accept) begin
            wdata_value <= s_wdata;// forget about IDs...
            wdata_strb  <= s_wstrb;
        end
    end
end
{% endhighlight %}

> 如果写请求的序与写数据的序不一致会怎样？

- 控制逻辑

~~~verilog
wire            rpipe_run;// read pipeline run
wire            wpipe_run;// write pipeline run

assign rbuf_last = (rbuf_len == 4'b0);
assign wbuf_last = (wbuf_len == 4'b0);

assign rd_accept =            s_arvalid & (~rbuf_busy | rbuf_last & rd_issue);
assign wr_accept = s_wvalid & s_awvalid & (~wbuf_busy | wbuf_last & wr_issue);

assign s_arready =            (~rbuf_busy | rbuf_last & rd_issue);
assign s_awready = s_wvalid & (~wbuf_busy | wbuf_last & wr_issue);

assign w_accept  = s_wvalid & (  wbuf_busy & ~wbuf_last & wr_issue |
                                 wbuf_busy & ~wdata_valid | 
                                (wbuf_busy &  wbuf_last & wr_issue | ~wbuf_busy) & s_awvalid);
assign s_wready = w_accept;

assign re_issue = rbuf_busy & (~bank_conflict | cflt_read ) & rpipe_run;
assign wr_issue = wbuf_busy & (~bank_conflict | cflt_write) & wpipe_run & wdata_valid;

assign rpipe_run = ~obuf_rd_valid[1] & ~obuf_wr_valid[1];// interlocked pipelines
assign wpipe_run = ~obuf_rd_valid[1] & ~obuf_wr_valid[1];
~~~

- RAM接口

~~~verilog
// address mapping
wire [4:0] rbank_id = rbuf_addr[15:12];
wire [4:0] wbank_id = wbuf_addr[15:12];
wire [11:0] roffset = rbuf_addr[11:0];
wire [11:0] woffset = wbuf_addr[11:0];

// deal with conflict
reg wr_prio;

wire bank_conflict = rbuf_busy & wbuf_busy & (rbank_id == wbank_id);
wire cflk_read     = bank_conflict & ~wr_prio;
wire cflt_write    = bank_conflict &  wr_prio;
always @(posedge aclk) wr_prio <= areset | bank_conflict ^ wr_prio;

wire [31:0] rb_sel = (32'h1 << rbank_id) & {32{rd_issue}};
wire [31:0] wr_sel = (32'h1 << wbank_id) & {32{wr_issue}};

wire         cen = ~(run & (r_sel | w_sel));//active low
wire [15:0]  wen = ~({16{w_sel}} & wstrb);
wire [7:0]   addr = {8{r_sel}} & raddr[11:4] | {8{w_sel}} & waddr[11:4];
wire [127:0] Q;
reg [127:0]  dat;
reg          read_d;
always @(posedge clk) begin
    if (rst) begin
        read_d <= 1'b0;
        dat    <= 128'b0;
    end
    else if (run) begin
        read_d <= ~cen & r_sel;
        dat    <= read_d ? Q : 128'b0;//dat
    end
end
~~~
</details>

## 内存总线