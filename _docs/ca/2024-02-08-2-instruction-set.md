---
title: 指令系统结构
tags: 计算机体系结构 学习笔记
permalink: /docs/ca/instruction-set
aside:
    toc: ture
sidebar:
    nav: computer_architecture
---

# 指令系统结构
## 指令系统简介
### 什么是指令系统
- 指令系统是计算机功能的抽象模型
  - 是软硬件的界面，所有软件最终以指令的形式运行
  - 体现了结构设计者对计算机系统及其应用的深刻理解
  - 一个指令系统可以有多种实现(低功耗、高性能、软件模拟)
- 指令系统结构不仅仅是关于指令功能的编码
  - 运行环境
  - 运行环境差异比功能差异大
### 指令系统为什么重要
- 指令系统是计算机产业的枢纽，产业生态的基础
  - 指令系统是计算机软硬件的重要标准
  - 决定**应用程序的二进制兼容**(Wintel和AA都做到)
  - 是**操作系统二进制兼容**(Wintel做到AA没做到)的重要因素
- 指令系统影响系统性能和实现复杂性
- 指令系统是不断发展的
## 指令系统的设计原则
   > 指令系统在计算机系统中的位置
   > - 硬件和软件的界面
   > - 反映了结构设计者对计算机系统的认识
### 设计原则
- 兼容性：对软件的包容性，长时间保持不变，如X86
- 通用性：对软件的易用性，编译器和程序员觉得好用
- 高效性：对硬件的易用性，便于CPU设计优化和不同性能的实现
- 安全性：对软硬件安全的支持，支持通用操作系统，考虑不同的安全要求
### 影响指令系统设计的因素
- 工艺技术
  - 早期的硬件昂贵，简化硬件是指令系统设计的主要因素
  - 后来集成度提高是的系统结构优化成为可能
  - 由于CPU速度和存储器速度的差距逐渐变大，为了弥补这个差距，指令系统应该能较好的利用存储层次，如通过并行或流水容忍延迟
    - Cache管理指令、预取指令
  - 工艺进一步发展，多核结构成为主流，需要指令系统增加访存一致性和核间同步的支持
- 系统结构
  - 指令系统本身是系统结构发展的结果
  - 指令系统的兼容性要求与系统结构发展的矛盾关系
  - 增加指令功能还是提高主频
  - 指令中如何体现并行性
- 操作系统
  - **操作系统专用的核心态指令和运行环境**
  - 多进程和虚空间
    - 页表和TLB的关系
    - 页保护：读写权限
  - 系统安全等级
    - 核心态和用户态管理
  - 异常和中断的处理
    - 异常处理入口、异常处理返回指令(ERTN)等
  - 访存和访问I/O的区别
  - 虚拟机：支持多操作系统的快速切换
- 编译技术与程序设计语言
  - 指令是编译器的工作结果
    - 早期的指令系统主要考虑如何便于编程
    - 后期兼顾便于编程和实现效率
  - 指令功能
    - 只有简单指令，甚至乘法都由加法和移位来实现
    - 具有复杂指令，如除法、开方
    - 更复杂的函数由库函数实现
  - 寄存器和存储器分配
    - 堆栈存放局部变量，全局数据区存放静态数据，堆存放动态数据
    - 为了有效使用图着色启发式算法，至少需要16个通用寄存器
  - 简单规整，提高编译效率
- 应用程序
  - 指令系统为应用设计
  - 应用要求指令系统保持兼容
## 指令系统的演变
### 指令内容的演变
- 依据指令长度的不同指令系统分为
  - 复杂指令系统(Complex Instruction Set Computer,简称CISC)，其指令长度可变
    - 早期的CPU昂贵的软硬件系统要求兼容性，指令集的不完善要求新增指令
  - 精简指令系统(Reduced Instruction Set Computer,简称RISC)，其指令长度比较固定
    - **简化指令间关系，有利于指令流水线高效实现**
    - 简化指令功能：执行时间短；简化指令编码：译码简单；简化访存类型：访存和运算可以分开
  - 超长指令字系统(Very Long Intruction Word,简称VLIW)，本质上是多条同时执行的指令的组合，其“同时执行”的特征由编译器指定，无需硬件进行判断
    - 指令级并行(Instruction Level Parallelism,简称ILP)的极端
  - 总体上看 RISC技术有利于指令流水线的高效实现，VLIW技术用于指令流水线优化不是很成功
  
![RISC、CISC、VLIW指令编码特点](./第二章图/不同指令内容的编码.png)
### 存储管理的演变
- 连续实地址
  - 各程序数据连续存放，显式保证不冲突
  - 内存碎片多，难以管理多个程序的空间分配
- 段式
  - 分为多个段，通过相对段的偏移来访问
  - 段表包含长度检查，偏移超过长度产生段错误
  - Segment Fault(段错误)
  - 地址结果通过加法得到，先根据段号检索段表，得到对应段的起始物理地址(由段长度和基址可得)，最后加上段内偏移得到最终的物理地址

![段式存储管理](./第二章图/段式存储管理.png)

  - 段内地址仍需连续
- 页式虚拟存储
  - 将虚地址和实地址的对应关系组织成页表，页表中包含有效、可写等标志信息
  - 地址结果通过页地址和页内地址组合得到。先根据虚拟页号检索页表得到对应的物理页号，再与页内偏移组合得到最终的物理地址
  - 通过TLB进行硬件支持

![页式存储管理](./第二章图/页式存储管理.png)
- 段页式：融合段式和页式
  - 先分段，段内分页
  - 先根据段号查询段表得到对应段的页表起始地址，再根据虚拟页号查询页表得到物理页号，与页内偏移组合得到最终的物理地址
  - 同样需要检查段地址的合法性

![段页式存储管理](./第二章图/段页式存储管理.png)
### 运行级别的演变
- 演变
  - 唯一实模式：无管理
  - 保护模式：权限管理
    - 核心态:掌握全部资源
    - 用户态:只能能访问受限的内存，不能访问I/O
  - 调试模式：调试支持
  - 客户模式：虚拟机支持
- LoongArch的运行级别
  - 调试模式(Debug Mode)
  - 主机模式(Host Mode)
    - Host-PLV0级
    - Host-PLV1级
    - Host-PLV2级
    - Host-PLV3级
  - 客户机模式(Guest Mode)
    - Guest-PLV0级
    - Guest-PLV1级
    - Guest-PLV2级
    - Guest-PLV3级
- LoongArch的虚拟机层次
  - 多个层次的隔离和控制
    - 应用程序：独立虚地址空间、寄存器
    - Guest操作系统：独立客户物理地址空间、控制状态寄存器，可管理应用程序的地址映射，转换到客户物理地址
    - Host操作系统：可管理客户系统的物理地址映射，转换到最终的根物理地址
  - 各个模式可访问/控制的资源呈包含关系
    - 主机模式和客户机模式下各有一组控制状态寄存器用于操作系统上下文的快速切换
  ![LoongArch各级别可访问资源](./第二章图/LoongArch各级别可访问资源.png)

  - 核心态的“特权”
    - 有些地方只有核心态可以访问
      - 控制寄存器、TLB、Cache、I/O空间、特定地址空间
      - 访问上述空间的指令在用户态运行时硬件发异常
    - 核心态和用户态的转换
      - 用户态下执行系统调用或发生异常时进入核心态
      - ERTN从核心态返回用户态
## 指令系统组成
   > 指令的主谓宾
   > - CPU、操作、操作数
   >
   >    **操作**
   > - 算术与逻辑运算、转移、访存、系统指令……
   >
   >    **操作数**
   > - 数据类型：定点/浮点，32位/64位……
   > - 访存对象：字节/半字/字/双字，大/小尾端……
   > - 寻址方式：寄存器、立即数、直接、间接……
   >
   >    **指令编码**
   > - 定长、变长
### 操作数的存储(地址空间)
- 寄存器空间
  - 整数通用寄存器
  - 浮点通用寄存器
  - 协处理器寄存器
  - 访问方式：在指令中以寄存器号引用
- 系统内存空间
  - 内存空间
  - IO空间
  - 访问方式：访存指令通过计算形成访存地址
  - X86规定了独立的IO空间，使用专门的in/out指令来访问
  - MIPS、ARM和LoongArch不区分，使用同样的访存指令
  - 处理器堆IO空间的访问通常不能经过Cache，在使用相同的load/store指令既访问IO空间又访问内存空间的情况下，需要定义所访问地址的存储访问类型来决定经不经过Cache
![经不经过Cache](./第二章图/经不经过Cache.png)
- 演变
  - 堆栈型(Stack):零地址指令
    - 操作数在栈顶，运算操作不用指定操作数
  - 累加器型：单地址指令
    - 一个操作数总在累加器中，结果也写回累加器
  - 寄存器型：多地址指令
    - Register-Register型(load-store型)
    - Register-Memory型
    - Memory-Memory型
    - 寄存器之间的相关性容易判断，易于实现流水线、多发射、乱序执行
    - 寄存器的访问速度快，便于编译器的使用和优化
![指令序列1](./第二章图/指令序列1.png)
![指令序列2](./第二章图/指令序列2.png)
### 操作数的表示
- 数据类型和大小
  - 类型：
    - 整数、实数、字符、十进制数
    - 字节、半字、字、双字
    - IEEE 754格式
  - 表示
    - 一般用操作码来区分不同类型
    - 专门的类型标志
- 访存对象
  - 存储器按字节编址
    - 所有地址都是字节地址
    - 访问长度：字节、半字、字、双字
  - 访存地址是否对齐(Aligned vs. Misaligned)
    - 地址对齐简化硬件设计：如字地址最低两位为0
    - 跨数据通路边界的访问可能要访问两次RAM
    - 如何支持不对齐访问(如串操作)
  - 大尾端(Big Endian)和小尾端(Little Endian)
    - 小尾端地址指向一个字的最右字节(低地址存放低字节)
- 寻址方式
![寻址方式](./第二章图/寻址方式.png)
其中mem表示存储器，regs表示寄存器，mem[regs[Rn]]表示由寄存器Rn的值作为存储器地址所访问的存储器的值
    - 至少要支持 Register(寄存器寻址) / Immediate(立即数寻址) / Dispalcement(偏移量寻址) / Register indirect(寄存器间接寻址) 寻址方式
    - 指令中常数位数
      - 地址偏移量12-16位
      - 立即数8-16位
### 指令操作和编码
- 指令操作
  - 算数和逻辑运算指令
    - 加、减、乘、除、开方……
    - 移位：左移与右移、逻辑移位与算术移位……
    - 与、或、非、异或……
    - 格式转换……
  - 访存指令：取数、存数
    - 不同长度和不同类型：定点/浮点；字节/半字/字/双字
    - 不同寻址方式
  - 转移指令
    - 指令类型
      - 条件转移/无条件转移
      - 过程调用/过程返回
    - 地址类型
      - 相对：PC+偏移量
      - 绝对：指令中给出转移地址
      - 间接：根据寄存器内容转移(编译器不知道目标地址)，如switch语句、函数指针、动态链接、过程返回、虚函数调用等
    - 特点
      - 条件转移最为常用
      - 条件转移通常只在转移指令附近跳转，偏移量一般不超过16位
      - 条件转移判定的两种实现方式
        - 比较专用标志位：运算指令生成条件位，转移指令判断条件位转移
        - X86、ARM、PowerPC、SPARC、MIPS浮点
        - 比较寄存器内容：转移指令直接判断寄存器内容大小决定是否转移
        - Aplha、MIPS定点、PA-RISC
  - 系统管理指令
    - TLB管理、Cache管理、异常管理、安全管理
- 指令编码
    操作数和操作码在整个指令码中的摆放方式
    - 考虑因素
      - 操作码部分比较简单
      - 操作数的个数、类型对指令长度影响很大
      - 变长指令程序代码短，定长指令实现简单
    - 编码方法
      - 定长：RISC
      - 变长：VAX的指令1-53字节，其中ADD指令3-19字节；Intel的X86指令1-17字节
      - 混合
- 一个“典型”的RISC
  - 32位定长指令
  - 32个32位通用寄存器
  - 三寄存器操作数运算指令
  - load-store指令，基址+偏移量寻址方式
  - 简单转移条件
## RISC指令系统比较
> MIPS、PA-RISC、PowerPC、SPARC、LoongArch
### 指令格式比较

![指令格式比较](./第二章图/指令格式比较.png)

### 寻址方式比较

![寻址方式比较](./第二章图/寻址方式比较.png)

### 指令功能比较
- 公共指令
  - load-store指令
    - 对任何GPR(通用寄存器)和FPR(浮点寄存器)进行存取操作，通常R0总是为0
  - 算术运算及逻辑指令
    - 所有ALU指令都是寄存器型的
    - 常见操作由加、减、与、或、异或、移位、比较，乘除法在专门的部件进行
  - 控制流指令
    - 间接跳转jump和相对转移branch
  - 系统管理指令
    - 原子操作指令
    - 存储管理指令
    - 例外管理指令
    - 共享存储同步指令
    - 等等
- 不同处理器在发展过程中形成的特色
  - MIPS的非对齐访问
    - 不对齐指令LWL/LWR
      - LWL将读取到的访存地址所在的字的最低位字节拼接到目标寄存器的高位
      - LWR将读取到的访存地址所在的字的最高位字节拼接到目标寄存器的低位
  - SPARC的寄存器窗口
    - 函数调用时不用保存现场，只需要切换寄存器组
  - PowerPC的Link和Count寄存器
    - Link寄存器用于保存返回地址，实现快速过程调用
    - Count寄存器用于循环计数，每次自动递减
  - PA-RISC的Nullification指令
    - 根据执行结果确定下一条指令是否执行
## C语言的机器表示
### 流程控制语句
- 分类
  - 选择语句：if\~else, switch\~case
  - 循环语句：for, while, do~while
  - 辅助控制语句：break, continue, goto, return
- C语言的控制流语句在LoongArch汇编中映射为各种分支指令(B类)或其组合
  - 选择语句和循环语句映射为条件分支
  - 辅助控制语句映射位无条件分支或跳转(return语句)
### 过程调用(详见第四章)